{
  "html": {
    "1": {
      "difficulty": 2,
      "question": "Ile tagów -[<h1>]- powinno być umieszczonych na jednej stronie?",
      "answers": [
        "Dokładnie jeden.",
        "Maksymalnie dwa.",
        "Nie ma ograniczeń.",
        "Taki tag nie istnieje."
      ],
      "explanation": "Tag -[<h1>]- ma za zadanie prezentować główny heading strony, wyjaśniający jej cel, dlatego zawsze powinien być tylko jeden. Pomijanie go to również błędny zabieg. Należy też pamiętać, że tagi h1-h6 mają za zadanie oznaczać semantyczne tytuły, podtytuły czy nagłówki na stronie, dlatego nic nie stoi na przeszkodzie by h1 był mniejszy i mniej widoczny niż h2. Założenie, że -[h1]- musi mieć większy -[font-size]- niż -[h2]-, -[h2]- większy niż -[h3]- itd. to błąd, nie należy mieszać wartości semantycznej z warstwą wizualną.",
      "moreInfoUrl": ""
    },
    "2": {
      "difficulty": 1,
      "question": "Do czego służy tag -[<ul>]-?",
      "answers": [
        "Do stworzenia nieposortowanej listy.",
        "Do stworzenia odnośnika (linku).",
        "Do stworzenia nagłówka.",
        "Do stworzenia posortowanej listy."
      ],
      "explanation": "-[<ul>]- (unordered list) to tag listy nieposortowanej, której podpunkty nie są ponumerowane, tzw. bullet list. Za pomocą CSS można zmienić wypunktowania w <ul>, nawet na \"a)\" lub \"1.\", jednak jest to zabieg błędny i całkowicie zbędny."
    },
    "3": {
      "difficulty": 2,
      "question": "Czym różni się -[<span>]- od -[<p>]-?",
      "answers": [
        "-[<span>]- to generyczny element -[inline]- bez wartości semantycznej, podczas gdy -[<p>]- to paragraf.",
        "-[<span>]- to generyczny element -[block]-, podczas gdy -[<p>]- to generyczny element -[inline-block]-",
        "-[<p>]- i -[<span>]- służą do tego samego, różnią się jedynie stylami (marginesy).",
        "-[<p>]- to element grupujący elementy -[<span>]-."
      ],
      "explanation": "-[<span>]- to generyczny element -[inline]-, odpowiednik blokowego -[div]-. Reguła stosowania jest identyczna jak w przypadku -[div]- - stosujemy go wtedy, gdy żaden inny semantyczny element -[inline]- nie pasuje."
    },
    "4": {
      "difficulty": 3,
      "question": "Do czego służy tag -[<em>]-?",
      "answers": [
        "Do oznaczenia tekstu, na który kładziemy nacisk.",
        "Do nałożenia kursywy na wybrany tekst.",
        "Do oznaczenia cytatu.",
        "Jest to generyczny element -[inline]- służący do stylowania tekstu."
      ],
      "explanation": "Tag -[<em>]- (emphasis) to dodany w HTML5 semantyczny tag mający nadawać nacisk na tekst w nim zawarty. Domyślnie nakłada kursywę na tekst, jednak równie dobrze możemy ostylować -[<em>]- na pogrubiony, czerwony kolor lub na zwykły tekst i -_nadal będzie to poprawne_-.",
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em"
    },
    "5": {
      "difficulty": 2,
      "question": "Jak wyświetlić obraz o ścieżce -[./images/logo.png]-, alternatywnym tekście \"Logo\" i wymiarach 160x50 px?",
      "answers": [
        "-[<img src=\"./images/logo.png\" alt=\"Logo\" class=\"logo\">]-, a wymiary nadać klasie w CSSie.",
        "-[<img href=\"./images/logo.png\" alt=\"Logo\" class=\"logo\">]-, a wymiary nadać klasie w CSSIe.",
        "-[<img src=\"./images/logo.png\" alt=\"Logo\" width=\"160\" height=\"50\">]-.",
        "-[<img href=\"./images/logo.png\" alt=\"Logo\" width=\"160\" height=\"50\">]-."
      ],
      "explanation": "Atrybut -[href]- jest niepoprawny dla tagu -[<img>]-, z kolei ustawienie wymiarów poprzez atrybuty -[width]- i -[height]- jest możliwe, jednak jest to zła praktyka. Zdecydowanie najlepszą opcją jest zarządzanie warstwą \"wizualną\" --- czyli jak coś wyświetlać --- za pomocą CSS."
    },
    "6": {
      "difficulty": 4,
      "question": "Do czego służy element -[<wbr>]-?",
      "answers": [
        "Do oznaczenia w którym miejscu pojawia się możliwość złamania tekstu.",
        "Do zakończenia linii.",
        "Do oznaczenia skrótu: -[<wbr title=\"Cascading Style Sheets\">CSS</wbr>]-",
        "Do nadania tekstowi nacisku."
      ],
      "explanation": "-[<wbr>]- to nowy tag, zaistniały w HTML5. Nie reprezentuje niczego \"fizycznego\", podobnie jak -[<br>]-, które jedynie łamie linię. Z kolei -[<wbr>]- służy do opcjonalnego złamania linii w miejscu w którym jest dodany, a samo złamanie linii nastąpi tylko wtedy gdy będzie to konieczne (np. bardzo długie słowo).\nNa marginesie, być może lepszym sposobem w języku Polskim jest użycie encji -[&shy;]- czyli soft-hypen, nie tylko umożlwiiającej opcjonalne łamanie linii, ale także dodanie \"-\" na końcu linii.",
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr"
    },
    "7": {
      "difficulty": 3,
      "question": "Dlaczego dodany został tag -[<strong>]- skoro mamy już -[<b>]-?",
      "answers": [
        "Tag -[<strong>]- służy do oznaczenia tekstu ważnego, podniesienia jego istoty.",
        "Tagi -[<strong>]- i -[<b>]- różnią się tym, że -[<strong>]- jeszcze bardziej pogrubia tekst.",
        "Tagi -[<b>]-, -[<i>]- i -[<u>]- są już wycofane. Tag -[<strong>]- to następca -[<b>]-.",
        "Oba te tagi służą do tego samego i mogą być zamiennie stosowane."
      ],
      "explanation": "Nie należy patrzeć na -[<strong>]- jako na element, którym pogrubimy tekst --- -_od tego mamy style CSS_-, lub tag -[<b>]-. Podobnie style -[<strong>]- nie są czymś istotnym i usunięcie pogrubienia, czy też zmiana koloru na czerwony będą jak najbardziej poprawnymi zmianami."
    },
    "8": {
      "difficulty": 1,
      "question": "Czym jest język HTML?",
      "answers": [
        "Jest to język znaczników, podstawowy budulec stron internetowych, pozwalający tworzyć elementy DOM.",
        "Jest to język programowania, stosowany w celu nadania stronie internetowej \"życia\".",
        "HTML to nowy język łączący w sobie znaczniki (tagi) oraz logikę (np. IF i ELSE, pętle FOR).",
        "Jest to rozszerzenie do Javascriptu i CSSa."
      ],
      "explanation": "HTML, tak jak np. XML, to język znaczników. Nie ma żadnych instrukcji for czy też if, nie wprowadza żadnej logiki. Jego jedynym zadaniem jest budowa dokumentu z wcześniej wspomnianych znaczników (tagów), do których później logikę dodajemy np. Javascriptem, a style CSSem."
    },
    "9": {
      "difficulty": 2,
      "question": "Czym różni się -[<input>]- od -[<input />]-? Który tag powinniśmy stosować w HTML5?",
      "answers": [
        "W HTML5 powinniśmy stosować -[<input>]-, jednak -[<input />]- jest również poprawny, to przykład taga bez zamknięcia, stosowany w XHTMLu.",
        "Oba te tagi są identyczne, po prostu -[<input />]- to nowsza wersja taga -[<input>]- i to jego należy używać.",
        "-[<input>]- stosujemy gdy chcemy umieścić tekst wewnątrz taga: -[<input>Nazwa inputa</input>]-. Bez tekstu wystarczy -[<input />]-.",
        "-[<input>]- służy do przycisków (-[<input type=\"button\">Wyślij</input>]-), podczas gdy -[<input />]- służy do pól formularza."
      ],
      "explanation": "XHTML to następca HTML 4.01 i przodek HTML5. Zawiera on elementy języka XML, gdzie możliwe jest automatyczne zamknięcie tagu bez zawartości, np.: -[<div></div>]- => -[<div />]-. Nie ma żadnej różnicy między -[<input>]- i -[<input />]-, jest to jedynie zapis z różnych wersji języka HTML. Warto jednak zwrócić uwagę, że w HTML5 składnia np.: -[<div />]- nie jest dozwolona.",
      "moreInfoUrl": "https://www.it-swarm-eu.dev/pl/html/czy-niewazne-samozamykajace-sie-tagi-sa-poprawne-w-html5/969196167/"
    },
    "10": {
      "difficulty": 2,
      "question": "Czym jest i jaką wartość semantyczną ma element -[<div>]-?",
      "answers": [
        "Nie ma żadnej. Jest to generyczny element, stosowany wszędzie tam, gdzie pozostałe, semantyczne elementy nie pasują.",
        "Jest to element rozdzielający, tzw. divider. Nie ma wartości semantycznej.",
        "Jest to semantyczny tag, oznaczający element oddzielony od głównej treści, niezwiązany z nią.",
        "Jest to posortowana lista, semantycznie służy do tworzenia list innych niż wypunktowane."
      ],
      "explanation": "W HTML5 stosujemy -[<div>]- wszędzie tam, gdzie nie pasują nam żadne inne elementy semantyczne, np. -[<main>]-, -[<section>]-, -[<footer>]- itd."
    },
    "11": {
      "difficulty": 3,
      "question": "Do czego stosujemy -[<table>]-?",
      "answers": [
        "Do tworzenia tabel oraz mailingów (najbardziej stabilna opcja tworzenia szablonów maili).",
        "-[<table>]- to najlepszy sposób na zbudowanie layoutu strony, ale nie nadaje się do szablonów maili.",
        "-[<table>]- wykorzystujemy aby nadać lub poprawić responsywność stron internetowych.",
        "Do tworzenia tabel oraz layoutów stron."
      ],
      "explanation": "W przeszłości tabele były popularną metodą tworzenia layoutu strony, dzieląc go na wiersze --- np. header, menu, sekcja pierwsze, sekcja druga, footer. Dziś jednak jest to jedynie przykre wspomnienie. Dużo osób jednak sądzi, że -[<table>]- to samo zło, jednak nadal jest to doskonałe narzędzie do tworzenia tabel lub elementów na stronie."
    },
    "12": {
      "difficulty": 4,
      "question": "Jaki cel ma ten kod?--[<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">]--",
      "answers": [
        "Jest to znacznik, który ustawia domyślne wyświetlanie strony na urządzeniu mobilnym.",
        "Jest to znacznik, który informuje urządzenie mobilne, że ta strona wspiera technologię renderowania -[viewport]-.",
        "Ma on na celu ustawienie domyślnego wyświetlania strony na urządzeniach typu desktop.",
        "Ma on na celu ustawienie ciemnego motywu na stronie, ."
      ],
      "explanation": "Znacznik meta to element zawierający metadane strony internetowej, czyli informacje o stronie oraz o tym, co zawiera, jak ma się wyświetlać, kto jest autorem itd. Powyższy tag definiuje domyślny sposób wyświetlania strony na urządzeniach mobilnych: ustawia jej szerokość, domyślne powiększenie czy możliwość powiększenia.",
      "moreInfoUrl": "https://developer.mozilla.org/pl/docs/Mozilla/Mobile/Viewport_meta_tag"
    },
    "13": {
      "difficulty": 2,
      "question": "Wybierz tagi, które można utworzyć wewnątrz -[<head>]-:",
      "answers": [
        "-[<meta>]-, -[<script>]-, -[<link>]-, -[<base>]-",
        "-[<style>]-, -[<main>]-, -[<script>]-, -[<title>]-",
        "-[<meta>]-, -[<link>]-, -[<embed>]-, -[<style>]-",
        "-[<href>]-, -[<script>]-, -[<title>]-, -[<link>]-"
      ],
      "explanation": "-[<meta>]- to tag zawierający metadane o stronie internetowej. -[<script]- pozwalana na załączenie skryptów do strony, może być umieszczony zarówno w -[<head>]- jak i w -[<body>]-. -[<link>]- to odnośnik do zasobów, np. styli, fontów czy skryptów. -[<base>]- to element ustawiający prefix wszystkich linków stronie."
    },
    "14": {
      "difficulty": 2,
      "question": "Który atrybut jest nieprawidłowy dla elementu -[<form>]-?",
      "answers": [
        "type",
        "action",
        "method",
        "novalidate"
      ]
    },
    "15": {
      "difficulty": 1,
      "question": "Który -[type]- przycisku nie istnieje?",
      "answers": [
        "input",
        "reset",
        "button",
        "submit"
      ],
      "explanation": "O ile istnieje -[<input type=\"button\">]-, o tyle nie spotkamy się z -[<button type=\"input\">]-."
    },
    "16": {
      "difficulty": 2,
      "question": "Czym różni się -[<input type=\"button\">]- od -[<button>]-?",
      "answers": [
        "Graficznie i funkcjonalnie niczym. Różnica w dodawaniu zawartości: -[<input type=\"button\" value=\"Przycisk\">]- vs -[<button type=\"button\">Przycisk</button>]-.",
        "Mają inne zastosowanie - -[<input type=\"button\">]- jest używany w formularzach, a -[<button>]- nie.",
        "Mają inne style - marginesy, padding i kolor - ale ich funkcjonalność jest identyczna.",
        "Nie istnieje input o -[type]- -[button]-."
      ],
      "explanation": "Nie ma żadnej różnicy w wyglądzie tych dwóch elementów. Znaczącą różnicą jest jednak fakt, że -[<button>]- pozwala nam dodać kontent przycisku między tagami, a więc możemy w nim umieścić inne tagi HTML, np. -[<img>]-."
    },
    "17": {
      "difficulty": 4,
      "question": "Do czego służy atrybut -[accesskey]-?",
      "answers": [
        "Pozwala na zdefiniowanie skrótu klawiszowego pod podanym klawiszem.",
        "Do ustawienia klucza dostępu do elementu (np. przycisku).",
        "Atrybut służy do podania wartości dla inputu, którą trzeba wpisać, aby wykonać przypisaną akcję (np. funkcję w Javascripcie).",
        "Taki atrybut nie istnieje."
      ],
      "explanation": "-[accesskey]- to atrybut z kategorii a11y, pozwalający na przypisanie do buttona jakiegoś skrótu klawiszowego. Najczęściej wykonuje się go kombinacją Alt + Shift + klawisz.",
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/accesskey"
    },
    "18": {
      "difficulty": 4,
      "question": "Co to jest a11y (accessibility)? Do czego służy?",
      "answers": [
        "Jest to zestaw rozwiązań i praktyk mających na celu umożliwienie przeglądania strony internetowej przez osoby z niepełnosprawnościami.",
        "To zestaw działań mający na celu łatwiejszy dostęp do naszej strony (m.in. SEO).",
        "To zbiór rozwiązań takich jak uwierzytelnianie i autoryzacja, mających na celu uprzywilejowanie użytkownika.",
        "Jest to błędnie nazwany zestaw dobrych praktyk, związanych z rozmieszczaniem przycisków w formularzu."
      ],
      "explanation": "Accessibility to zestaw rozwiązań takich jak atrybuty, np.: -[aria-label]-, dobre praktyki, np.: nie usuwanie property -[outline]- z elementów, utrzymywanie rozsądnego kontrastu między elementami itd."
    },
    "19": {
      "difficulty": 2,
      "question": "Czy element -[<div>]- może być zawarty w elemencie -[<span>]-?",
      "answers": [
        "Nie, ponieważ -[<span>]- to element -[inline]-, a -[<div>]- to element -[block]-. W elementach -[inline]- mogą być umieszczone tylko inne elementy -[inline]-.",
        "Tak, ponieważ -[<span>]- to element -[inline]-, a -[<div>]- to element -[block]-. W elementach -[inline]- mogą być umieszczone wszystkie inne typy elementów.",
        "Nie, ponieważ -[<span>]- to element -[block]-, a -[<div>]- to element -[inline]-. W elementach -[block]- mogą być umieszczone tylko inne elementy -[block]-.",
        "Tak, ponieważ -[<span>]- to element -[block]-, a -[<div>]- to element -[inline]-. W elementach -[block]- mogą być umieszczone wszystkie inne typy elementów."
      ]
    },
    "20": {
      "difficulty": 1,
      "question": "Wybierz wszystkie błędy w tym kodzie. Zakładamy, że nie ma żadnego stylowania.\n--[<a src=\"index.html\">\n  <div>\n    <img href=\"logo.png\"></img>\n  </div>\n</a>]--",
      "answers": [
        "-[<a>]- ma błędny atrybut -[src]-, -[<div>]- w -[<a>]- oraz -[<img>]- bez atrybutu -[alt]-, z błędnym atrybutem -[href]- i tagiem zamykającym.",
        "-[<a>]- ma błędny atrybut -[src]-, -[<div>]- w -[<a>]-, -[<img>]- w -[<a>]- i z błędnym atrybutem -[href]- oraz brakiem atrybutu -[alt]-.",
        "-[<a>]- z brakiem atrybutu -[target]-, -[<img>]- ma błędny atrybut -[href]- oraz ma tag zamykajacy.",
        "-[<div>]- w -[<a>]- oraz -[<img>]- z tagiem zamykającym."
      ],
      "explanation": "-[<a>]- nie posiada atrybutu -[src]- (zamiast tego -[href]-) i jest to element liniowy --- to znaczy, że może zawierać w sobie jedynie inne elememty liniowe, a więc -[<div>]- jest tutaj niepoprawny. Dodatkowo -[<img]- nie ma parametru -[href]-, a -[src]-, brakuje wymaganego tagu -[alt]- (nawet jeżeli miałby być pusty) i nie powinien mieć tagu zamykającego."
    },
    "21": {
      "difficulty": 3,
      "question": "Do czego służy tag -[<aside>]-?",
      "answers": [
        "Do elementów i treści mniej powiązanych z główną treścią lub nie powiązanych wcale.",
        "Do wyświetlania elementów z boku strony, np. bocznego menu, sidebara.",
        "Do wyświetlenia elementów, które nie mają żadnego związku z główną treścią, np. reklam.",
        "Tag -[<aside>]- używany jest do elementów rozwijanych horyzontalnie i takich, które wysuwają się z boku strony."
      ],
      "explanation": "-[<aside>]- wcale nie musi być \"z boku\" strony, może to być np. mniej powiązane zdanie w artykule. Jednak może to być także np. sidebar czy reklama. Generalnie elementy trochę związane z główną treścią - np. cytaty, przypisy, wyjaśnienie, a także w ogóle z nią nie związane - np. reklamy."
    },
    "22": {
      "difficulty": 3,
      "question": "Czy istnieje możliwość wyświetlania innego obrazu na telefonie i komputerze za pomocą samego HTMLa?",
      "answers": [
        "Tak, służy do tego element -[<picture>]- i w nim zawarte (opcjonalne) elementy -[<source>]- i jeden -[<img>]-.",
        "Tak, służy do tego element -[<source>]- i w nim zawarte (opcjonalne) elementy -[<picture>]- i jeden -[<img>]-.",
        "Nie, jest to możliwe tylko przy użyciu CSS.",
        "Nie, jest to możliwe tylko przy użyciu Javascriptu."
      ],
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source"
    },
    "23": {
      "difficulty": 3,
      "question": "Do czego służy tag -[<header>]-?",
      "answers": [
        "Do oznaczenia headera całej strony, artykułu, sekcji lub jakiegoś bloku.",
        "Jest to element będący headerem strony lub podstrony. Powinien być tylko jeden na stronie, tak jak -[<h1>]-.",
        "To element przed -[<body>]-, w którym zawieramy metadane strony, tytuł czy odnośniki do zasobów.",
        "-[<header>]- i -[<footer>]- to elementy, które muszą być w tagu -[<main>]- i określają kolejno header i footer strony."
      ]
    },
    "24": {
      "difficulty": 4,
      "question": "Czym jest atrybut -[aria-role]-?",
      "answers": [
        "Jest to atrybut definiujący cel i typ elementu dla urządzeń asystujących.",
        "Jest to atrybut z serii ARIA, atrybut zmieniający rodzaj elementu. -[aria-role=\"button\"]- sprawi, że nasz -[div]- będzie wyglądał i działał jak -[button]-.",
        "To atrybut definiujący rolę elementu, wymagany aby przeglądarka wiedziała, czy -[<header>]- jest headerem strony czy artykułu.",
        "To stary atrybut stosowany do oznaczenia roli elementu -[<div>]- zanim jeszcze pojawił się semantyczny HTML5 z tagami takimi jak -[<header>]-, -[<footer>]- itd."
      ],
      "explanation": "ARIA to zbiór atrybutów umożliwiających dostosowanie strony internetowej dla urządzeń asystujących, np. czytników dla osób niewidomych. Dzięki atrybutowi -[aria-role]- możemy zdefiniować typ oraz cel elementu, który go nie posiada - np. -[<div>]- czy -[<span>]- lub nadpisać domyślny. W większości przypadków atrybut ten nie jest potrzebny.",
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques"
    },
    "25": {
      "difficulty": 4,
      "question": "Do czego służy tag -[<map>]-?",
      "answers": [
        "Pozwala utworzyć dowolną liczbę kształtów na obrazie, będących odnośnikami.",
        "Jest to semantyczny tag będący kontenerem map, np. Google Maps.",
        "Pozwala utworzyć interaktywną mapę, określoną tagiem -[src]-.",
        "Jest to tag umożliwiający dodanie kilku obrazów w jednym elemencie w dowolny sposób."
      ],
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map"
    },
    "26": {
      "difficulty": 1,
      "question": "Jeden z elementów -[option]- w elemencie -[select]- musi być zablokowany. Jakim atrybutem tego dokonamy?",
      "answers": [
        "-[disabled]-",
        "-[readonly]-",
        "-[selected]-",
        "-[label]-"
      ]
    },
    "27": {
      "difficulty": 1,
      "question": "Jakiego atrybutu użyć, aby pole w formularzu było obowiązkowe?",
      "answers": [
        "required",
        "mandatory",
        "valid",
        "obligatory"
      ]
    },
    "28": {
      "difficulty": 1,
      "question": "Jak dodać podpowiedź w polu, która zniknie gdy zaczniemy w nim pisać?",
      "answers": [
        "-[<input type=\"text\" placeholder=\"Nazwa\">]-",
        "-[<input type=\"text\" alt=\"Nazwa\">]-",
        "-[<input type=\"text\" label=\"Nazwa\">]-",
        "-[<input type=\"text\" title=\"Nazwa\">]-"
      ]
    },
    "29": {
      "difficulty": 3,
      "question": "Jak możemy ograniczyć wybierane pliki w inpucie typu -[file]- do zdjęć w formacie JPEG?",
      "answers": [
        "-[<input type=\"file\" name=\"plik\" accept=\"image/jpeg\">]-",
        "-[<input type=\"file\" name=\"plik\" type=\"image/jpeg\">]-",
        "-[<input type=\"file\" name=\"plik\" codetype=\"image/jpeg\">]-",
        "-[<input type=\"file\" name=\"plik\" allow=\"image/jpeg\">]-"
      ]
    },
    "30": {
      "difficulty": 4,
      "question": "Jak nadać sekcji -[<section]- tytuł?",
      "answers": [
        "Używajac wewnątrz niej nagłówka -[<h_>]-.",
        "Nie ma takiej możliwości.",
        "Nadając jej atrybut -[id]-.",
        "Używając wewnątrz niej elementu z atrybutem -[aria-role=\"title\"]-."
      ]
    }
  },

  "css": {
    "1": {
      "difficulty": 2,
      "question": "Względem czego pozycjonuje się element z -[position: absolute]-?",
      "answers": [
        "Względem najbliższego przodka o -[position]- innym niż -[static]-. Jeżeli takiego nie ma, to względem viewportu.",
        "Względem rodzica, którego -[position]- nie ma żadnego wpływu.",
        "Względem viewportu.",
        "Względem najbliższego przodka o -[position]- nie innym niż -[relative]-."
      ],
      "explanation": "-[position: absolute]- opuszcza domyślny flow dokumentu, dopasowując się do najbliżsezgo przodka o -[position]- innym niż -[static]-. Może się jednak zdarzyć, że takiego przodka nie ma - wówczas element ustawi się względem okna (viewportu)."
    },
    "2": {
      "difficulty": 2,
      "question": "Które elementy będą miały czerwone tło?:--[.list .item {\n  background-color: red;\n}]--\n--[<div class=\"list\">\n  <div class=\"item\">item 1</div>\n  <div class=\"item\">item 2</div>\n  <div class=\"item\">\n    <div class=\"item\">item 3</div>\n    <div class=\"item\">item 4</div>\n    <div class=\"item\">\n      <div class=\"item\">item 5</div>\n      <div class=\"item\">item 6</div>\n    </div>\n  </div>\n</div>]--",
      "answers": [
        "Wszystkie elementy -[.item]-.",
        "Elementy -[.item]- \"item 1\" i \"item 2\"",
        "Elementy -[.item]- poza \"item 1\" i \"item 2\"",
        "Żaden element nie będzie miał czerwonego tła."
      ],
      "explanation": "-[.list .item]- to selektor, który zadziała dla wszystkich elementów o klasie -[.item]- zawartych w elemencie -[.list]- i wszystkich elementach, które są w nim zawarte."
    },
    "3": {
      "difficulty": 3,
      "question": "Jaki kolory będą miały elementy?--[<p class=\"parent\">\n  <span id=\"item-1\" class=\"item-1\" data-name=\"item-1\">Item 1</span>\n  <span id=\"item-2\" class=\"item-2\" data-name=\"item-2\" style=\"color: limegreen\">Item 2</span>\n  <span id=\"item-3\" class=\"item-3\" data-name=\"item-3\">Item 3</span>\n</p>]--\n--[.parent > * {\n  beige;\n}\n\n.item-1 {\n  color: steelblue !important;\n}\n\n.parent span {\n  color: coral;\n}\n\n.parent > .item-3 {\n  color: darkslateblue;\n}\n\n.parent #item-3 {\n  color: hotpink;\n}\n\n.parent .item-1,\n.parent .item-2 {\n  color: chocolate;\n}]--",
      "answers": [
        "Kolejno: -[steelblue]-, -[limegreen]- i -[hotpink]-.",
        "Kolejno: -[chocolate]-, -[limegreen]- i -[darkslateblue]-.",
        "Kolejno: -[chocolate]-, -[chocolate]- i -[darkslateblue]-.",
        "Kolejno: -[steelblue]-, -[chocolate]- i -[hotpink]-."
      ],
      "explanation": "Pierwszy -[<span>]- będzie o kolorze -[steelblue]- ponieważ reguła -[!important]- jest ponad wszystkimi innymi regułami. Następny element będzie w kolorze -[limegreen]-, ponieważ specificity stylów inline jest najwyższym możliwym. Ostatni element będzie w kolorze -[hotpink]- ponieważ selektor id ma większe specificity niż jakiekolwiek kombinacje selektorów klas."
    },
    "4": {
      "difficulty": 3,
      "question": "Wybierz w odpowiedniej kolejności coraz konkretniejsze style (o większym specificity).",
      "answers": [
        "-[span]-, -[span > span]-, -[.item]-, -[.parent > .item]-, -[#parent]-, -[#parent .item]-, style inline.",
        "-[span]-, -[.item]-, -[#parent]-, -[span > span]-, -[.parent > .item]-, -[#parent .item]-, style inline.",
        "style inline, -[span]-, -[#parent]-, -[.item]-, -[span > span]-, -[#parent .item]-, -[.parent > .item]-.",
        "-[#parent]-, -[span]-, -[.item]-, -[span > span]-, -[#parent .item]-, -[.parent > .item]-, style inline."
      ],
      "explanation": "W CSSie istnieje kluczowa charakterystyka zwana -_specificity_-, określająca konkretność danego selektora. Oznacza to, że każdy selektor (-[*]-, -[.parent + .parent]-, -[#parent > .item button]- itd.) ma swoje odwzorowanie w liczbie. Tag = 1, klasa = 10, id = 100, inline = 1000."
    },
    "5": {
      "difficulty": 1,
      "question": "Jakie property służy do zmiany rozmiaru tekstu?",
      "answers": [
        "-[font-size]-",
        "-[size]-",
        "-[text-size]-",
        "-[font]-"
      ]
    },
    "6": {
      "difficulty": 1,
      "question": "Czym różni się property -[background]- od -[background-color]-?",
      "answers": [
        "-[background]- to skrót wielu property ustawiających tło, np.: -[background-color]-, -[background-repeat]-, -[background-position]- itd.",
        "-[background]- to property do ustawienia obrazu jako tła, podczas gdy -[background-color]- służy do ustawienia koloru tła.",
        "-[background]- ustawia kolor tła dla elementu i wszystkich jego dzieci, podczas gdy -[background-color]- tylko dla tego konkretnego elementu.",
        "-[background]- to skrót od -[background-color]- i niczym się te property nie różnią."
      ],
      "explanation": "-[background]- to tzw. -_shorthand_-, czyli skrót od innych property, w tym przypadku od wszystkich zaczynających się na \"background-\". Wartości podane w odpowiedniej kolejności pozwolą na ustawienie koloru, rozmiaru, położenia, powtarzania tła, a także na wiele innych opcji."
    },
    "7": {
      "difficulty": 3,
      "question": "Jaki efekt ma reguła -[* { box-sizing: border-box; }]-?",
      "answers": [
        "-[box-sizing]- o wartości -[border-box]- sprawia, że -[padding]- i -[border]- wliczają się do rozmiaru elementu. -[*]- to selektor oznaczający każdy element.",
        "-[box-sizing]- o wartości -[border-box]- sprawia, że -[padding]- wlicza się do rozmiaru elementu. -[*]- to selektor oznaczający każdy element.",
        "-[box-sizing]- o wartości -[border-box]- sprawia, że -[padding]-, -[border]- i -[margin]- wliczają się do rozmiaru elementu. -[*]- to selektor oznaczający każdy element.",
        "-[box-sizing]- o wartości -[border-box]- sprawia, że -[padding]- nie wlicza się do rozmiaru elementu. -[*]- to selektor oznaczający każdy element."
      ],
      "explanation": "Jest to bardzo podstawowa reguła, pozwalajaca na wliczenie paddingu i bordera do rozmiaru elementu. Dzięki tej regule, ustawiając elementowi np. -[width: 200px; height 200px;]- mamy pewność, że element ten jest dokładnie takiego rozmiaru. Bez takiej reguły, element mający np. 8px paddingu i border 1px miałby wymiary 218x218 px."
    },
    "8": {
      "difficulty": 2,
      "question": "Jak ostylować wszystkie elementy występujące tuż po tagu -[<code>]-?",
      "answers": [
        "-[code + *]-",
        "-[code ~ *]-",
        "-[code > *]-",
        "-[code:after(*)]-"
      ],
      "explanation": "-[+]-, -[~]-, -[>]- itd. w selektorach CSS to tzw. kombinatory. Pozwalają one na wybranie elementów bez bezpośredniego ich wybrania. Aby wybrać element będący tuż po -[code]-, czyli -_adjacent sibling_-, stosujemy kombinator -[*]-.",
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator"
    },
    "9": {
      "difficulty": 3,
      "question": "Jaką przewagę ma zmienna CSS nad zmienną w np. Sassie?",
      "answers": [
        "Zmienne z języków rozszerzających CSS - jak np. Sass (SCSS) - zostają skompilowane i znikają z arkusza styli, z kolei zmienne CSSowe nadal istnieją po załadowaniu strony, dodatkowo można się do nich odwołać Javascriptem.",
        "Zmienne z języków rozszerzających CSS - jak np. Sass (SCSS) - zostają skompliowane i znikają z arkusza styli, podczas gdy zmienne w CSSie nadal istnieją po załadowaniu strony. Nie ma innych różnic.",
        "Zmienne CSS są globalne, tj. nie trzeba importować pliku, w którym je zdefiniowaliśmy. To jedyna zaleta tego rozwiązania.",
        "Zmienne CSS nie mają przewagi nad zmiennymi w np. Sassie, ponieważ trzeba je deklarować w selektorze -[:root]- i odwoływać się do nich skomplikowaną składnią."
      ],
      "explanation": "Zmienne CSS --- mimo skomplikowanej składni --- posiadają szereg zalet, takich jak dostępność po wyświetleniu strony internetowej, możliwość edycji javascriptem i wiele innych. Mało kto jednak wie, że zmienne CSSowe nie mogą zostać użyte np. wyrażeniach logicznych media query."
    },
    "10": {
      "difficulty": 3,
      "question": "Jak zadeklarować i użyć zmiennej w CSS?",
      "answers": [
        "--[:root {\n  --color: lightblue;\n}\n\nbody {\n  background-color: var(--color);\n}]--",
        "--[:root {\n  color: lightblue;\n}\n\nbody {\n  background-color: var(--color);\n}]--",
        "--[:root {\n  color: lightblue;\n}\n\nbody {\n  background-color: --var(color);\n}]--",
        "--[:root {\n  --var(color): lightblue;\n}\n\nbody {\n  background-color: --var(color);\n}]--"
      ]
    },
    "11": {
      "difficulty": 1,
      "question": "Jaka jest różnica między marginesem, a paddingiem?",
      "answers": [
        "Padding to odstęp pomiędzy zawartością elementu (contentem), a ramką (borderem).",
        "Padding to odstęp poza elementem (za ramką).",
        "Padding to inaczej ramka, jest pomiędzy marginesem, a borderem.",
        "Padding to margines dla elementów -[inline]-."
      ],
      "explanation": "Przede wszystkim padding zalicza się do modelu pudełkowego. Jest to przestrzeń bezpośrednio otaczająca content. Następnie mamy border, a później - już poza box modelem - margin."
    },
    "12": {
      "difficulty": 2,
      "question": "Czym się różni element -[inline]- od elementu -[block]-?",
      "answers": [
        "Element inline ma ustawione własności -[width]- i -[height]- na -[auto]-, ich zmiana nic nie da. Nie działają też marginesy -[top]- i -[bottom]-, a paddingi -[top]- i -[bottom]- nakładają się, ale nie mają żadnego wpływu. Marginesy i paddingi -[left]- i -[right]- zachowuja się normalnie. Nie działa -[transform]-. Pozycjonowany jest obok innego elementu jeżeli jest taka możliwość.",
        "Element inline ma ustawione własności -[width]- i -[height]- na -[auto]-, ich zmiana nic nie da. Nie działa na niego margines -[top]- i -[bottom]-. Pozostałe -[margin-left]-, -[margin-right]-, a także -[padding]- i -[transform]- działają normalnie. Pozycjonowany jest obok innego elementu jeżeli jest taka możliwość.",
        "Element inline ma ustawione własności -[width]- i -[height]- na -[auto]-, ale można je dowolnie zmienić. Działają wszystkie marginy i paddingi, ale nie działa property -[transform]-. Pozycjonowany jest obok innego elementu jeżeli jest taka możliwość.",
        "Element inline ma ustawione własności -[width]- i -[height]- na -[auto]-, ale można je dowolnie zmienić. Działają tylko marginesy i paddingi -[left]- i -[right]-. Można stosować -[transform]-. Pozycjonowany jest obok innego elementu jeżeli jest taka możliwość."
      ],
      "explanation": "Element -[inline]-, to taki który pozycjonuje się w linii. Jego szerokość i wysokość jest automatyczna, czyli najmniejsza jaka jest potrzebna. Takie elementy nie mają marginesu -[top]- i -[bottom]-, a padding -[top]- i -[bottom]- choć się nakłada, to nie ma wpływu na inne elementy. Mało znanym faktem jest też to, że faktycznie -[transform]- na takich elementach nie działa."
    },
    "13": {
      "difficulty": 3,
      "question": "Co to jest pseudoklasa? Co to jest pseudoelement?",
      "answers": [
        "Pseudoklasa to selektor stanu. Poprzedza go -[:]-. Przykład: -[:hover]-, -[:focus]-, -[:active]-. Pseudoelement to \"wewnętrzny\" element w innym elemencie, np. w divie, poprzedzony -[::]-. Przykład: -[::before]-, -[::after]-, -[::placeholder]-.",
        "Pseudoklasa to selektor stanu. Poprzedza go -[::]-. Przykład: -[::hover]-, -[::focus]-, -[::active]-. Pseudoelement to \"wewnętrzny\" element w innym elemencie, np. w divie, poprzedzony -[:]-. Przykład: -[:before]-, -[:after]-, -[:placeholder]-.",
        "Pseudoklasa to selektor, którego budowa to -[<nazwa-tagu>.<nazwa-klasy>]-, np. -[button.active]-. Pseudoelement (lub Pseudoidentyfikator) to selektor, którego budowa to <nazwa-tagu>#<nazwa-id>, np. -[button#next-step]-.",
        "Pseudoklasa to selektor, którego budowa to -[$<nazwa-klasy>]-, np. -[$active]-. Pseudoelement (lub Pseudoidentyfikator) to selektor, którego budowa to @<nazwa-pseudoid>, np. -[@next-step]-."
      ],
      "explanation": "Z reguły pseudoelement poprzedzony jest -[::]- (wyjątek stanowi implementacja IE) np. -[::before]-, natomiast -_zawsze_- pseudoklasa poprzedzona jest -[:]-, np. -[:placeholder-shown]-. Pseudoelement to faktyczny element, który możemy ostylować, ustawić mu wymiary, tło, animować go. Może być dodany do każdego elementu -_nie-void_-, czyli takiego, który ma zamknięcie. Oznacza to, że nie można dodać pseudoelementów np. elementowi -[<input>]- czy -[<hr>]-."
    },
    "14": {
      "difficulty": 2,
      "question": "Czym się różni id od klasy? Czego powinniśmy używać do stylowania elementów?",
      "answers": [
        "Id to unikalna nazwa elementu. Jeden element może mieć maksymalnie 1 id. Klas natomiast może mieć wiele i to po nich powinniśmy stylować. Przykłady: -[#przykladowe-id]-, -[.przykladowa-klasa]-.",
        "Klasa to unikalna nazwa elementu. Jeden element może mieć maksymalnie 1 klasę. Id natomiast może mieć wiele i to po nich powinniśmy stylować. Przykłady: -[#przykladowe-id]-, -[.przykladowa-klasa]-.",
        "Id to unikalna nazwa elementu. Jeden element może mieć maksymalnie 1 id. Klas natomiast może mieć wiele i to po nich powinniśmy stylować. Przykłady: -[.przykladowe-id]-, -[#przykladowa-klasa]-.",
        "Klasa to unikalna nazwa elementu. Jeden element może mieć maksymalnie 1 klasę. Id natomiast może mieć wiele i to po nich powinniśmy stylować. Przykłady: -[.przykladowe-id]-, -[#przykladowa-klasa]-."
      ],
      "explanation": "Element może mieć dowolną liczbę klas (-[.klasa]-), oddzielonych spacją, ale maksymalnie jedno id (-[#id]-). Atrybut typu -[id=\"id-1 id-2\"]- sprawi, że \"id-1 id-2\" będzie -_jedną_- wartością id tego elementu. Powinniśmy unikać nazw tagów i id jako selektorów."
    },
    "15": {
      "difficulty": 2,
      "question": "Wyjaśnij różnice między: -[.item1.item2]-, -[.item1 .item2]-, -[.item1 > .item2]-.",
      "answers": [
        "-[.item1.item2]- to wszystkie elementy o dwóch klasach -[.item1]- i -[.item2]-, -[.item1 .item2]- to wszyscy potomkowie elementu -[.item1]- mający klasę -[.item2]-, natomiast -[.item1 > .item2]- to wszyscy bezpośredni potomkowie (dzieci) elementu -[.item1]- mające klasę -[.item2]-.",
        "-[.item1.item2]- to wszystkie elementy o klasie -[.item1]- lub -[.item2]- (wystarczy jedna). -[.item1 .item2]- to dzieci elementu -[.item1]- mające klasę -[.item2]-, natomiast -[.item1 > .item2]- to błąd, gdyż w CSSie nie używam operatorów arytmetycznych.",
        "-[.item1.item2]- to wszystkie elementy o klasie -[.item1.item2]-, -[.item1 .item2]- to wszyscy potomkowie elementu -[.item1]- mające klasę -[.item2]-. -[.item1 > .item2]- to elementy o klasie -[.item2]- będące bezpośrednio po elementach o klasie -[.item1]-.",
        "-[.item1.item2]- to błąd, -[.item1 .item2]- z kolei to wszyscy potomkowie elementu -[.item1]- mający klasę -[.item2]-. -[.item1 > .item2]- to elementy o klasie -[.item2]- będące bezpośrednio lub niebezpośrednio po elementach o klasie -[.item1]-."
      ],
      "explanation": "-[.item1.item2]- to selektor jednego elementu o co najmniej tych klasach. -[.item1 .item2]- to selektor ze spacją --- kombinatorem potomków, a więc każdy element o klasie -[.item2]- będący pomiędzy tagami elementu -[.item1]-. -[>]- to kombinator dziecka, czyli bezpośredniego potomka."
    },
    "16": {
      "difficulty": 3,
      "question": "Wyjaśnij różnice między: -[.item1 .item2]-, -[.item1 + .item2]-, -[.item1 ~ .item2]-.",
      "answers": [
        "Pierwszy selektor to wszyscy potomkowie elementu -[.item1]- mający klasę -[.item2]-. Drugi to elementy o klasie -[.item2]- będące bezpośrednio po elementach o klasie -[.item1]-. Trzeci to elementy o klasie -[.item2]- będące bezpośrednio lub niebezpośrednio po elementach o klasie -[.item1]-.",
        "Pierwszy selektor to wszystkie dzieci (bezpośredni potomkowie) elementu -[.item1]- mające klasę -[.item2]-. Drugi to elementy o klasie -[.item2]- będące bezpośrednio po elementach o klasie -[.item1]-. Trzeci to elementy o klasie -[.item2]- będące bezpośrednio lub niebezpośrednio po elementach o klasie -[.item1]-.",
        "Pierwszy selektor to wszystkie dzieci (bezpośredni potomkowie) elementu -[.item1]- mające klasę -[.item2]-. Drugi to elementy o klasie -[.item2]- będące bezpośrednio lub niebezpośrednio po elementach o klasie -[.item1]-. Trzeci to elementy o klasie -[.item1]- będące bezpośrednio po elementach o klasie -[.item2]-.",
        "Pierwszy selektor to wszyscy potomkowie elementu -[.item1]- mający klasę -[.item2]-. Drugi to wszystkie dzieci (bezpośredni potomkowie) elementu -[.item1]- mające klasę -[.item2]-. Trzeci to elementy o klasie -[.item2]- będące bezpośrednio lub niebezpośrednio po elementach o klasie -[.item1]-."
      ]
    },
    "17": {
      "difficulty": 4,
      "question": "Wyjaśnij różnicę między jednostkami: -[px]-, -[em]-, -[rem]-.",
      "answers": [
        "-[px]- to jednostka pikseli. -[1px]- to 1 piksel. -[em]- to mnożnik \"obecnego\" rozmiaru tekstu, a więc jeżeli -[font-size]- elementu to -[16px]-, to -[width: 2em]- wyniesie w rzeczywistości -[32px]-. -[rem]- to mnożnik wartości -[font-size]- w tagu -[html]-. Jeżeli ustawimy w html -[font-size: 10px]-, to -[1rem]- = -[10px]-.",
        "-[px]- to jednostka pikseli. -[1px]- to 1 piksel. -[rem]- to mnożnik \"obecnego\" rozmiaru tekstu, ustawiany w selektorze html. Jeżeli w html ustawimy -[rem-size: 1.5]-, to mając -[font-size: 16px]- -[1rem]- wyniesie -[24px]-. -[em]- to mnożnik wartości -[font-size]- w tagu -[html]-. Jeżeli ustawimy w html -[font-size: 10px]-, to -[1em]- = -[10px]-.",
        "-[px]- to jednostka pikseli. -[1px]- to 1 piksel. -[em]- to jednostka znaków, a więc element z -[width: 5em]- będzie długi na 5 znaków \"0\". -[rem]- to nowa jednostka rozmiaru tekstu, stosowania tylko w preprocesorach takich jak Sass czy Less.",
        "-[px]- to jednostka pikseli. -[1px]- to 1 piksel. -[em]- to mnożnik \"obecnego\" rozmiaru tekstu, ustawiany w selektorze html. Jeżeli w html ustawimy -[em-scale: 1.5]-, to mając -[font-size: 16px]- -[1em]- wyniesie -[24px]-. -[rem]- to mnożnik wartości -[font-size]- w tagu -[html]-. Jeżeli ustawimy w html -[font-size: 10px]-, to -[1rem]- = -[10px]-."
      ],
      "explanation": "Jednostka -[em]- to mnożnik obecnego rozmiaru tekstu, czyli zdefiniowanego w elemencie lub w najbliższym przodku, który ma zdefiniowany -[font-size]-, gdyż to property jest dziedziczone. Dla przykładu -[<span>]- będący w -[<h1>]- z regułą -[font-size: 2em]- będzie miał dwukrotnie większy rozmiar tekstu niż h1.\nJednostka -[rem]- działa na podobnej zasadzie, jednak zawsze mnoży -[font-size]- zadeklarowany w selektorze rootowym, najczęściej w -[html]-.",
      "moreInfoUrl": "https://love-coding.pl/rem-em-jednostki-miary-w-css/"
    },
    "18": {
      "difficulty": 2,
      "question": "Co reprezentuje jednostka -[ch]-?",
      "answers": [
        "Jednostka -[ch]- reprezentuje szerokość znaku \"0\", czyli -[width: 10ch]- to taka sama szerokość jak dziesięć takich znaków.\nWielkość ta zależy od obecnego -[font-size]-.",
        "Jednostka -[ch]- reprezentuje szerokość znaku \"0\", czyli -[width: 10ch]- to taka sama szerokość jak dziesięć takich znaków.\nWielkość ta zależy od -[font-size]- w selektorze -[html]- (domyślnie 16px).",
        "Jednostka -[ch]- reprezentuje szerokość znaku \"0\", czyli -[width: 10ch]- to taka sama szerokość jak dziesięć takich znaków.\nWielkość ta jest niezależna i zawsze chodzi o \"0\" o -[font-size: 16px]-.",
        "Jednostka -[ch]- reprezentuje szerokość znaku \"0\", czyli -[width: 10ch]- to taka sama szerokość jak dziesięć takich znaków.\nWielkość ta jest niezależna i zawsze chodzi o \"0\" o -[font-size: 10px]-."
      ],
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/CSS/length"
    },
    "19": {
      "difficulty": 3,
      "question": "Jak zaznaczyć elementy -[<a>]-, których wartość atrybutu -[href]- kończy się na \".pdf\"?",
      "answers": [
        "-[a[href$=\".pdf\"]]-",
        "-[a[href^=\".pdf\"]]-",
        "-[a[href*=\".pdf\"]]-",
        "-[a[href#=\".pdf\"]]-"
      ],
      "explanation": "W CSSie możemy wybrać tylko elementy zawierające konkretne atrybuty i ich wartości, np. -[a[href]]- aby zaznaczyć -[a]- posiadające atrybut -[href]-. Możemy także wyszczególnić, że wartość tego atrybutu powinna kończyć się wartością \".pdf\" w ten sposób: -[href$=\".pdf\"]-.\nWarto dodać, że opcja -[href*=\".pdf\"]- także zadziała, ponieważ wyszukuje podanej wartości w całej wartości atrybutu, ale oznacza to również, że może nie zadziałać tak, jakbyśmy tego oczekiwali."
    },
    "20": {
      "difficulty": 3,
      "question": "Jak zaznaczyć elementy -[<a>]-, których wartość atrybutu -[href]- zaczyna się od \"https\"?",
      "answers": [
        "-[a[href^=\"https\"]]-",
        "-[a[href$=\"https\"]]-",
        "-[a[href*=\"https\"]]-",
        "-[a[href#=\"https\"]]-"
      ],
      "explanation": "W CSSie możemy wybrać tylko elementy zawierające konkretne atrybuty i ich wartości, np. -[a[href]]- aby zaznaczyć -[a]- posiadające atrybut -[href]-. Możemy także wyszczególnić, że wartość tego atrybutu powinna zaczynać się od wartości \"https\" w ten sposób: -[href^=\"https\"]]-.\nWarto dodać, że opcja -[href*=\"https\"]]- także zadziała, ponieważ wyszukuje podanej wartości w całej wartości atrybutu, a więc może nie zadziałać tak, jakbyśmy tego oczekiwali.",
      "moreInfoUrl": ""
    },
    "21": {
      "difficulty": 3,
      "question": "Co to jest Sass, Less albo Stylus?",
      "answers": [
        "Są to preprocesory języka CSS, czyli rozszerzenia dające nam nowe możliwości, ostatecznie kompilowane do czystego kodu CSS.",
        "Są to postprocesory języka CSS, umożliwiające optymalizację kodu CSS (usunięcie nieużywanych lub powtarzających się reguł, grupowanie selektorów o tych samych regułach itd.",
        "Są to następcy języka CSS, trzy implementacje bazujące na CSS, ale znacznie go rozszerzające. Kod ten nie musi być kompilowany, stosowany w przeglądarkach od paru lat.",
        "Są to następcy języka CSS, łączący w sobie CSS i Javascript, tzw. CSS-in-JS. Style pisane są w Javascripcie."
      ],
      "explanation": "Preprocesor języka CSS to narzędzie pozwalające na wydajniejsze tworzenie styli, dzięki możliwościom takim jak zmienne (nie mylić ze zmiennymi CSS), mixiny, pętle for, instrukcje if, czy nawet zagnieżdżanie reguł styli.",
      "moreInfoUrl": "https://code.tutsplus.com/pl/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320"
    },
    "22": {
      "difficulty": 2,
      "question": "Co to jest flexbox? Jak działa?",
      "answers": [
        "Flexbox to zestaw własności i wartości wprowadzających nowe możliwości układania elementów na stronie, jest to tzw. jednowymiarowy model. Jest to jeden z popularniejszych sposobów tworzenia layoutów.",
        "Flexbox to zestaw własności i wartości wprowadzających możliwości układania elementów na stronie, jest to tzw. jednowymiarowy model. Jest to przestarzała technologia wyparta przez technologię float, czyli dwuwymiarowy model.",
        "Flexbox to zestaw własności i wartości wprowadzających nowe możliwości układania elementów na stronie, jest to tzw. dwuwymiarowy model. Pozwala tworzyć responsywną siatkę elementów.",
        "Flexbox to zestaw własności i wartości wprowadzających responsywność w stronach internetowych. Jest to najpopularniejsza metoda, wypierająca dawniej stosowane media query."
      ],
      "explanation": "\"Moduł\" flexible box, czyli potocznie flexbox, to relatywnie stara technologia, jednak obecnie zdecydowanie razem z gridem najbardziej popularna w tworzeniu zarówno layoutu strony, jak i rozmieszczenia mniejszych elementów. Jest to podstawa każdego front end developa w dzisiejszych czasach."
    },
    "23": {
      "difficulty": 3,
      "question": "Co to jest grid? Jak działa?",
      "answers": [
        "Grid to dwuwymiarowy model layoutu, dzielący stronę lub element na regiony, w których można umieszczać inne elementy.",
        "Grid to jednowymiary model layoutu, potocznie nazywany Flex lub Flexbox. Jest to najpopularniejsza technologia tworzenia layoutów stron internetowych.",
        "Grid to jednowymiary model layoutu, potocznie nazywany Flex lub Flexbox. Jest to przestarzała technologia tworzenia layoutów stron internetowych, której powinniśmy unikać.",
        "Grid to dwuwymiarowy model layoutu, który ma działać na zasadzie dzielenia strony na siatkę elementów. Wersja eksperymentalna jest już dostępna, jednak nie ma na razie szerokiego wsparcia przeglądarek."
      ]
    },
    "24": {
      "difficulty": 1,
      "question": "Jaki będzie rozmiar tekstu h1?:--[<div>\n  <h1>Tytuł</h1>\n</div>]--\n--[div {\n  font-size: 16px;\n}\n\nh1 {\n  font-size: 2em;\n}]--",
      "answers": [
        "-[32px]-",
        "-[16px]-",
        "-[20px]-",
        "-[18px]-"
      ],
      "explanation": "-[em]- to jednostka mnożąca obecny -[font-size]- - czyli w tym przypadku dziedziony rozmiar tekstu rodzica (-[div]-). 2 * 16px daje 32px."
    },
    "25": {
      "difficulty": 4,
      "question": "Co to jest -[outline]- i dlaczego nie powinniśmy ustawiać go na -[none]-?",
      "answers": [
        "-[outline]- to obrys pojawiający się domyślnie na elementach z pseudoklasą -[:focus]-, np. po kliknięciu przycisku. Nie powinniśmy go usuwać ze względu na accessibility.",
        "-[outline]- to obrys pojawiający się między -[margin]-em, a -[border]-em, jest to obrys dookoła ramki elementu. Rzadko stosowana pozostałość po HTML4.01.",
        "-[outline]- to obrys pojawiający się między -[padding]-iem, a -[border]-em, jest to obrys wewnątrz ramki elementu. Rzadko stosowana pozostałość po HTML4.01.",
        "-[outline]- to podkreślenie widoczne np. po najechaniu na link. Może zostać zastosowane w każdym elemencie, poprzez nadanie grubości, stylu i koloru."
      ],
      "explanation": "Accessibility to zestaw praktyk i rozwiązań ułatwiających korzystanie ze strony internetowej osobom z niepełnosprawnościami. Widoczny outline to zwiększone accesibility, ponieważ nie usuwa oznaczenia, że element jest wybrany. Jest to także przydatne dla osób nawigujących po stronie klawiszem Tab. Alternatywą dla -[outline: none]- jest nadanie innych styli na -[:focus]-, aby zachować to oznaczenie."
    },
    "26": {
      "difficulty": 4,
      "question": "Do czego służy -[@media]-?",
      "answers": [
        "Jest to reguła umożliwiająca nadanie styli w określonym scenariuszu --- np. w widoku drukowania, na ekranach o maksymalnej szerokości 600px, gdy preferowany jest ciemny motyw itd.",
        "Jest to reguła umożliwiająca zaimportowanie elementów takich jak obrazy czy fonty do arkusza styli, aby móc później używać ich jako zmiennych do ustawienia ścieżki.",
        "Jest to reguła umożliwiająca nadanie styli responsywnych, tj. ustawienie styli na telefony, tablety i PC, podczas gdy -[@prefers]- umożliwia nadanie styli, gdy użytkownik preferuje np. ciemny motyw.",
        "Jest to reguła z preprocesora Sass, stosowana do importowania innych plików styli."
      ],
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/CSS/@media"
    },
    "27": {
      "difficulty": 4,
      "question": "Jak stworzyć media query tylko dla telefonów w pionie o maksymalnej wysokości 600px i maksymalnej szerokości 360px?",
      "answers": [
        "-[@media (max-width: 360px) and (max-height: 600px) and (orientation: portrait) and (any-pointer: coarse)]-",
        "-[@media handheld and (max-width: 360px) and (max-height: 600px) and (orientation: portrait)]-",
        "-[@media handheld and (max-width: 360px) and (max-height: 600px)]-",
        "-[@media handheld and (max-width: 360px) and (max-height: 600px) and (orientation: portrait) and (any-pointer: fine)]-"
      ],
      "explanation": "-[handheld]- to przestarzała wartość, której nie należy już stosować. Warto również użyć -[any-pointer: coarse]- co sprawi, że reguła weźmie pod uwagę urządzenia z ekranem dotykowym."
    },
    "28": {
      "difficulty": 4,
      "question": "Wyjaśnij ten selektor: -[[aria-role=navigation] > ul a:not([href^=mailto])]-",
      "answers": [
        "Szukamy w elemencie o atrybucie -[aria-role=navigation]- elementów -[a]-, których atrybut -[href]- zaczyna się tekstem -[mailto]-.",
        "Szukamy w elemencie o atrybucie -[aria-role=navigation]- elementów -[a]-, których atrybut -[href]- nie kończy się tekstem -[mailto]-.",
        "Szukamy elementów o atrybucie -[aria-role=navigation]- będących obok elementów -[a]- o atrybucie -[href]- nie kończącym się tekstem -[mailto]-.",
        "Selektor jest niepoprawny, ponieważ powinno być -[*[aria-role=\"navigation\"]]-."
      ]
    },
    "29": {
      "difficulty": 2,
      "question": "Jaki jest najlepszy sposób żeby wykonać animację przesunięcia elementu o 200px w lewo i 50px w dół?",
      "answers": [
        "-[transform: translate(...)]-",
        "-[left]- i -[top]-",
        "-[padding-left]- i -[padding-top]-",
        "-[margin-left]- i -[margin-top]-"
      ],
      "explanation": "-[transform: translate]- to najwydajniejszy sposób na animację zmiany pozycji elementów. Warto również dodać wtedy property -[will-change]- pozwalające przeglądarace \"przygotować się\" do takiej zmiany."
    },
    "30": {
      "difficulty": 4,
      "question": "Jaki będzie wizualny rezultat tego kodu:--[<div>\n  <input type=\"text\" class=\"pole\">\n</div>]--\n--[.pole {\n  position: relative;\n}\n\n.pole::before {\n  content: '*';\n  position: absolute;\n  right: -10px;\n  top: 0;\n}]--",
      "answers": [
        "Będzie to zwykłe pole tekstowe.",
        "Będzie to pole tekstowe z \"*\" po prawej stronie, poza polem.",
        "Będzie to pole tekstowe z \"*\" po lewej stronie, poza polem.",
        "Będzie to pole tekstowe z \"*\" po prawej stronie, wewnątrz pola."
      ],
      "explanation": "Pułapka, o której warto wiedzieć --- elementy \"void\", czyli takie, które nie mają tagu zamykającego, jak -[<input>]-, -[<hr>]-, -[<br>]- itd. nie mogą posiadać pseudoelementów --- w końcu nie posiadają kontentu."
    },
    "31": {
      "difficulty": 1,
      "question": "Które property pozwala zmienić odległość między literami w tekście?",
      "answers": [
        "-[letter-spacing]-",
        "-[letter-distance]-",
        "-[white-space]-",
        "-[word-spacing]-"
      ]
    },
    "32": {
      "difficulty": 1,
      "question": "Wybierz wartość lewego marginesu: -[margin: 10px 20px 30px 40px;]-",
      "answers": [
        "-[40px]-",
        "-[30px]-",
        "-[20px]-",
        "-[10px]-"
      ]
    },
    "33": {
      "difficulty": 4,
      "question": "Jaki będzie kolor ramki elementu -[button]-?:--[<div>\n  <form>\n    <button type=\"button\">Przycisk</button>\n  </form>\n</div>]--\n--[div {\n  border-color: red;\n}\n\ndiv > form {\n  border-color: blue;\n}\n\nbutton {\n  border: 1px solid;\n  color: green;\n}]--",
      "answers": [
        "-[green]-",
        "-[red]-",
        "-[blue]-",
        "Domyślny - czarny"
      ],
      "explanation": "-[border-color]- nie jest dziedziczonym property, więc tak naprawdę kolory obramowania jego rodziców są nieistotne. W przypadku gdy nie jest podany kolor ramki, jest to kolor tekstu, dlatego zazwyczaj jest to czarny. Jednak zmiana koloru tekstu, zmieni w tym przypadku również kolor ramki."
    },
    "34": {
      "difficulty": 1,
      "question": "Jak wybrać ostatni element -[<li>]-?--[<ul>\n  <li>pierwszy</li>\n  <li>drugi</li>\n  <li>trzeci</li>\n</ul>]--",
      "answers": [
        "-[li:last-child]-",
        "-[li:last-element]-",
        "-[li:last-item]-",
        "-[li:child(-1)]-"
      ]
    },
    "35": {
      "difficulty": 4,
      "question": "Jak wybrać ostatni element -[<p>]-?--[<article>\n  <p>pierwszy</p>\n  <p>drugi</p>\n  <p>trzeci</p>\n  <footer>stopka</footer>\n</article>]--",
      "answers": [
        "-[p:last-of-type]-",
        "-[article:last-child]-",
        "-[p:last-child]-",
        "-[article:last-of-items]-"
      ]
    },
    "36": {
      "difficulty": 1,
      "question": "Jak usunąć podkreślenie z wszystkich linków na stronie?",
      "answers": [
        "--[a {\n  text-decoration: none;\n}]--",
        "--[a {\n  text-underline: none;\n}]--",
        "--[a {\n  bottom-line: none;\n}]--",
        "--[a {\n  bottom-underline: none;\n}]--"
      ]
    }
  },

  "javascript": {
    "1": {
      "difficulty": 1,
      "question": "Wybierz poprawne różnice między -[const]-, -[let]- i -[var]-.",
      "answers": [
        "-[let]- i -[const]- mają zasięg (scope) blokowy, -[var]- podlega windowaniu (\"hoisting\"), -[const]- musi mieć zdefiniowaną wartość podczas deklaracji i nie może ona zostać zmieniona.",
        "Wszystkie zmienne podlegają windowaniu (\"hoisting\"), wartość -[const]- nie może ulec zmianie, -[let]- w przeciwieństwie do -[var]- nie może być deklarowany w pętli, gdyż deklaracja zniknęłaby w następnym jej obrocie.",
        "-[var]- i -[const]- podlegają windowaniu (\"hoisting\"), dodatkowo -[const]- ma zasięg (scope) blokowy, a jego wartość nie może zostać zmieniona. -[let]- może być wielokrotnie deklarowany.",
        "-[var]- ma zasięg (scope) blokowy, -[let]- i -[const]- podlegają windowaniu (\"hoisting\"), -[const]- musi mieć zdefiniowaną wartość podczas deklaracji i nie może być ona zmieniona."
      ],
      "explanation": "-[let]- i -[const]- to relatywnie nowe rodzaje zmiennych. W porównaniu do -[var]-, mają one zasięg blokowy, tj. zadeklarowane w instrukcji blokowej (np. -[if]- czy -[for]-) nie są dostępne poza nią. Nie podlegają windowaniu, czyli wyniesieniu deklaracji zmiennej na początek funkcji. Dodatkowo -[const]- ma służyć do stałych, czyli deklaracji wartości, która nie może być zmieniona. Nie można napisać deklaracji -[const x;]-, gdyż stała musi mieć zdefiniowaną wartość."
    },
    "2": {
      "difficulty": 1,
      "question": "Jaki typ zmiennej zastosować jako licznik w pętli -[for]-?",
      "answers": [
        "-[let]-, aby zmienna nie istniała poza pętlą, jeżeli tego nie chcemy.",
        "-[var]-, aby zmienna nie istniała poza pętlą, jeżeli tego nie chcemy.",
        "Musi to być -[var]- ponieważ -[let]- byłby -[undefined]- po pierwszym obrocie pętli.",
        "Bez znaczenia: może to być -[var]-, -[let]- czy -[const]-."
      ],
      "explanation": "Pomijając skrajne przypadki, gdy chcemy mieć dostęp do licznika pętli, np. zmiennej -[i]-, stosujemy zmienną -[let]-: -[for (let i = 0; i < 10; i++)]-. Dzięki temu, po zakończeniu instrukcji pętli, nie mamy dostępu do zmiennej -[i]-."
    },
    "3": {
      "difficulty": 3,
      "question": "Co się stanie w takiej sytuacji?\n--[x = 5;\nvar x;\nconsole.log(x);]--",
      "answers": [
        "-[console.log]- wyświetli wartość -[5]-.",
        "Wystąpi błąd - zmienna -[x]- nie istnieje.",
        "Wystąpi błąd - nie można zmienić wartości -[var]-.",
        "-[console.log]- wyświetli wartość -[undefined]-."
      ],
      "explanation": "W wyniku procesu zwanego \"hoisting\" deklaracja -[var x;]- zostanie \"wywindowana\" na początek kodu, w wyniku czego inicjalizacja -[x = 5]- zadziała bez zarzutu.",
      "moreInfoUrl": "https://love-coding.pl/co-to-jest-hoisting-w-javascript/"
    },
    "4": {
      "difficulty": 2,
      "question": "Co się stanie w takiej sytuacji?\n--[x = 5;\nlet x;\nconsole.log(x);]--",
      "answers": [
        "Wystąpi błąd - zmienna -[x]- nie istnieje.",
        "-[console.log]- wyświetli wartość -[5]-.",
        "Wystąpi błąd - nie można zmienić wartości -[let]-.",
        "-[console.log]- wyświetli wartość -[undefined]-."
      ],
      "explanation": "-[let]- nie podlega procesowi \"hoisting\", przez co zmienna -[x]- nie jest dostępna przed jej deklaracją."
    },
    "5": {
      "difficulty": 1,
      "question": "Co się stanie w takiej sytuacji?\n--[x = 5;\nconst x;\nconsole.log(x);]--",
      "answers": [
        "Wystąpi błąd - wartość -[const]- musi mieć zainicjalizowaną wartość.",
        "Wystąpi błąd - zmienna -[x]- nie istnieje.",
        "-[console.log]- wyświetli wartość -[5]-.",
        "Wystąpi błąd - nie można zmienić wartości -[const]-."
      ],
      "explanation": "-[const]- to stała, której wartość można zainicjalizować tylko raz i musi to być wartość podana podczas deklaracji. Nie jest możliwe zadeklarowanie stałej: -[const x;]- i zdefiniowanie jej wartości później. Kod -[x = 5;]- nie będzie uznany za błąd ponieważ poza trybem -[strict]- Javascript jest \"wyrozumiały\". Więcej o trybie -[strict]-:",
      "moreInfoUrl": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"
    },
    "6": {
      "difficulty": 2,
      "question": "Co to jest \"hoisting\"?",
      "answers": [
        "Jest to proces wyniesienia deklaracji -[var]- na początek kodu lub funkcji.",
        "Jest to proces wyniesienia deklaracji zmiennych na początek kodu lub funkcji.",
        "To dobra praktyka, mówiąca o tym, że deklaracje zmiennych -[var]- powinny być umieszczanie na początku kodu lub funkcji.",
        "To dobra praktyka, mówiąca o tym, że deklaracje wszystkich zmiennych powinny być umieszczanie na początku kodu lub funkcji."
      ],
      "explanation": "Hoisting to proces ułatwiający życie programistom Javascript, wynoszący deklaracje zmiennych -[var]- na początek instrukcji. Oznacza to, że taki kod: -[console.log(x); var x = 5;]- nie zwróci błędu, gdyż w momencie wykonania skryptu, deklaracja -[var x;]- zostanie przeniesiona przed funkcję -[console.log]-.",
      "moreInfoUrl": "https://love-coding.pl/co-to-jest-hoisting-w-javascript/"
    },
    "7": {
      "difficulty": 1,
      "question": "Jak znaleźć element o klasie -[.element]-:--[<p>\n  <span class=\"tekst\"></span>\n  <span class=\"element\"></span>\n  <span class=\"podpis\"></span>\n</p>]--",
      "answers": [
        "-[document.getElementsByClassName('element')[0];]-",
        "-[document.getElementsByClassName('.element')[0];]-",
        "-[document.getElementByClassName('element');]-",
        "-[document.getElementByClassName('.element');]-"
      ],
      "explanation": "Obiekt -[document]- posiada metodę -[getElementsByClassName]- pobierającą samą nazwę klasy CSSowej - w tym przypadku -[element]-. Należy zwrócić uwagę, że zwracana nie jest listą typu -[Array]-, a -[HTMLCollection]-, która różni się np. brakiem metod -[forEach]- czy -[map]-."
    },
    "8": {
      "difficulty": 2,
      "question": "Jak znaleźć elementy -[button]- o -[type=\"submit\"]-?",
      "answers": [
        "-[document.querySelectorAll('button[type=submit]');]-",
        "-[document.querySelector('button[type=submit]');]-",
        "-[document.getElementsByAttribute('type', 'submit', 'button')[0];]-",
        "-[document.getElementByAttribute('type', 'submit', 'button');]-"
      ],
      "explanation": "Obiekt -[document]- nie posiada metod -[getElementByAttribute]- ani -[getElementsByAttribute]-. Z kolei metody -[querySelector]- i -[querySelectorAll]- znajdują odpowiednio: element i -[HTMLCollection]- elementów."
    },
    "9": {
      "difficulty": 2,
      "question": "Co zwróci to porównanie?: -[\"1\" == 1]-",
      "answers": [
        "-[true]-, ponieważ operator -[==]- dokonuje konwersji typów jeżeli jest to konieczne.",
        "-[true]- ponieważ w Javascripcie -[string]- zawierający liczbę automatycznie konwertowany jest na -[number]-.",
        "-[false]-, ponieważ typy wartości są różne.",
        "-[false]-, ponieważ Javascript konwertujes stringi na ich wartość ASCII, a w tym przypadku wartość ASCII znaku \"1\" nie wynosi 1, a 49."
      ],
      "explanation": "W Javascripcie mamy dwa operatory porównania. Operator -[===]- to strict comparison, czyli porównanie i typów i wartości --- takie porównanie zwróciłoby -[false]-. Natomiast operator -[==]- sprawdza typy, a jeżeli są rózne, ale możliwa jest konwersja to jej dokonuje. W tym przypadku -[\"1\"]- zostaje zamienione na -[1]-, stąd -[true]-."
    },
    "10": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tej nierówności?: -[-Infinity < NaN]-",
      "answers": [
        "-[false]-",
        "-[true]-",
        "-[undefined]-",
        "Błąd: zmienna -[Infinity]- nie została zadeklarowana."
      ],
      "explanation": "W Javascripcie mamy dwie bardzo małe wartości, jedna to -[Number.MIN_VALUE]-, a druga to -[-Infinity]-. O ile ta druga w każdym innym przypadku okaże się być najmniejsza, o tyle -[NaN]- nie stosuje się do reguł arytmetyki --- zarówno -[0 > NaN]-, -[0 == NaN]-, -[0 === NaN]- jak i -[0 < NaN]- zwróci false. Nawet -[NaN === NaN]-."
    },
    "11": {
      "difficulty": 3,
      "question": "Podaj wartość zwracaną z tego polecenia: -[typeof NaN]-.",
      "answers": [
        "-['number']-",
        "-['object']-",
        "-['function']-",
        "-['NaN']-"
      ],
      "explanation": "Choć wydaje się to nielogiczne to -[NaN]- (Not a Number) jest typu -[number]-.",
      "moreInfoUrl": "https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/NaN"
    },
    "12": {
      "difficulty": 1,
      "question": "Jaki będzie wynik tego kodu?\n--[const array = [1, 2, 3];\nconsole.log(array[3]);]--",
      "answers": [
        "-[undefined]-",
        "-[3]-",
        "-[null]-",
        "Wystąpi błąd."
      ],
      "explanation": "Wynikiem będzie -[undefined]-, gdyż odwołujemy się do elementu o indeksie 3 tablicy -[array]-. Ta tablica ma zdefiniowane elementy o indeksach 0, 1 i 2, a więc element o indeksie 3 nie jest zdefiniowany (stąd \"undefined\")."
    },
    "13": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu?\n--[const array = [1, 2, 3, 5];\nconsole.log(array.indexOf(3));]--",
      "answers": [
        "-[2]-",
        "-[-1]-",
        "-[3]-",
        "-[5]-"
      ],
      "explanation": "Metoda -[indexOf]- zwraca indeks pierwszego znalezionego elementu o podanej wartości. W tym przypadku była to trójka znajdująca się na pozycji drugiej --- w Javascripcie, jak w wielu językach programowania, indeksujemy od zera."
    },
    "14": {
      "difficulty": 1,
      "question": "Które z działań da taki sam wynik jak -[wynik += liczba]-?",
      "answers": [
        "-[wynik = wynik + liczba]-",
        "-[wynik = liczba + liczba]-",
        "-[wynik = ++liczba]-",
        "-[wynik = liczba++]-"
      ],
      "explanation": "Operator -[+=]- to skrót od zdefiniowania wartości zmiennej jako wartości tej zmiennej zsumowanej do prawej wartości. A więc -[wynik += liczba]- to to samo co -[wynik = wynik + liczba]-."
    },
    "15": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu: -[console.log(\"2021\" - \"1995\");]-?",
      "answers": [
        "-[26]-",
        "-[NaN]-",
        "-[null]-",
        "Wystąbi błąd."
      ],
      "explanation": "Operator -[-]- w razie potrzeby konwertuje wartości na liczby, przez co ostatecznie działanie to to nic innego jak -[2021 - 1995]-. Stąd też wynikają takie \"smaczki\" jak -[\"20\" - 4 = 16; \"20\" + 4 = \"24\"]- - w drugim  przypadku -[+]- konwertuje -[4]- na -[\"4\"]-."
    },
    "16": {
      "difficulty": 3,
      "question": "Który z tych operatorów nie jest operatorem logicznym?",
      "answers": [
        "-[|]-",
        "-[!]-",
        "-[||]-",
        "-[&&]-"
      ],
      "explanation": "Operatory -[!]-, -[||]-, -[&&]- to operatory logiczne, kolejno: zaprzeczenia (NOT), \"lub\" (OR) oraz \"i\" (AND). W czystym Javascripcie -[|]- to operator bitowy."
    },
    "17": {
      "difficulty": 1,
      "question": "Wybierz poprawną składnię komentarzy w Javascripcie:",
      "answers": [
        "/* Komentarz */",
        ">> Komentarz",
        "/ Komentarz /",
        ";; Komentarz"
      ]
    },
    "18": {
      "difficulty": 2,
      "question": "W Javascripcie mamy dużo swobody, ale są też pewne ograniczenia. Wybierz przykład niepoprawnej nazwy zmiennej:",
      "answers": [
        "4wynik",
        "_wynik",
        "$wynik",
        "wynik$"
      ],
      "explanation": "Nazwy zmiennych nie mogą zaczynać się cyfrą."
    },
    "19": {
      "difficulty": 4,
      "question": "Wybierz wynik poniższego kodu:\n--[let x = 43;\nconsole.log(x++);]--",
      "answers": [
        "-[43]-",
        "-[44]-",
        "-[45]-",
        "-[\"43++\"]-"
      ],
      "explanation": "Operator inkrementacji -[++]- może być dodany jako prefiks lub sufiks. Warto wiedzieć, że użyty jako sufiks (-[zmienna++]-) zwraca wartość zmiennej przed jej inkrementacją (zwiększeniem o 1), natomiast prefiks (-[++zmienna]-) zwróci wartość zmiennej po jej inkrementacji."
    },
    "20": {
      "difficulty": 4,
      "question": "Wybierz wynik poniższego kodu:\n--[let x = 43;\nconsole.log(++x);]--",
      "answers": [
        "-[44]-",
        "-[43]-",
        "-[45]-",
        "-[\"++43\"]-"
      ],
      "explanation": "Operator inkrementacji -[++]- może być dodany jako prefiks lub sufiks. Warto wiedzieć, że użyty jako prefiks (-[++zmienna]-) zwraca wartość zmiennej po jej inkrementacji (zwiększeniu o 1), natomiast sufiks (-[zmienna++]-) zwróci wartość przed inkrementacją."
    },
    "21": {
      "difficulty": 3,
      "question": "Jaki wynik da ten kod: -[console.log(100 && 5);]-?",
      "answers": [
        "-[5]-",
        "-[100]-",
        "-[105]-",
        "-[true]-"
      ],
      "explanation": "Operator logiczny -[&&]- zwraca pierwszą wartość -_falsy_-, czyli taką, którą da się przekonwertować na -[false]-. Jeżeli takiej nie ma, zwraca ostatnią. -[Boolean(100)]- zwróci true, a więc wynikiem jest -[5]-. Gdyby przykładem było -[0 && 5]- otrzymalibyśmy -[0]-."
    },
    "22": {
      "difficulty": 3,
      "question": "Jaki wynik da ten kod: -[console.log(100 || 5);]-?",
      "answers": [
        "-[100]-",
        "-[5]-",
        "-[105]-",
        "-[true]-"
      ],
      "explanation": "Operator logiczny -[||]- zwraca pierwszą wartość -_truthy_-, czyli taką, którą da się przekonwertować na -[true]-. Jeżeli takiej nie ma, zwraca ostatnią. -[Boolean(100)]- zwróci true, a więc wynikiem jest -[100]-. Gdyby przykładem było -[0 || 5]- otrzymalibyśmy wynik -[5]-."
    },
    "23": {
      "difficulty": 3,
      "question": "Jaki będzie wynik tego kodu?\n--[const array = [1, 2, 3];\narray.shift();\nconsole.log(array);]--",
      "answers": [
        "-[[2, 3]]-",
        "-[[1, 2, 3]]-",
        "-[[3, 2, 1]]-",
        "-[[undefined, 1, 2, 3]]-"
      ],
      "explanation": "Metoda -[shift]- zwraca pierwszy element tablicy i usuwa go z niej. A więc po jednym takim wykonaniu z tablicy usuwamy element -[1]-."
    },
    "24": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu?--[let isLogged = false;\nconst role = isLogged ? 'Zalogowany' : 'Gość';]--",
      "answers": [
        "-['Gość']-",
        "-['Zalogowany']-",
        "-[false]-",
        "Wystąpi błąd."
      ],
      "explanation": "Tzw operator warunkowy: -[warunek ? wyrażenie1 : wyrażenie2]-, gdzie wyrażenie1 występuje jeżeli warunek jest spełniony, w przeciwnym wypadku wykonane jest wyrażenie2. W powyższym przykładzie zmienna -[isLogged]- ma wartość -[false]-, a więc przypisana zostaje druga wartość: -['Gość']-."
    },
    "25": {
      "difficulty": 1,
      "question": "Jaki będzie wynik tego kodu: -[console.log(3 ** 3);]-?",
      "answers": [
        "-[27]-",
        "-[9]-",
        "-[6]-",
        "Wystąpi błąd."
      ]
    },
    "26": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu: -[console.log(!!null);]-?",
      "answers": [
        "-[false]-",
        "-[true]-",
        "-[NaN]-",
        "-[null]-"
      ],
      "explanation": "Operator zaprzeczenia zostaje tu użyty dwukrotnie, a więc rozbijmy przykład na dwa kroki: 1. zamieniamy null na przeciwną dla niego wartość boolean. null jest wartością -_falsy_-, a więc konwertowaną do -[false]-, dlatego -[!null]- da nam -[true]-. Ponowne zaprzeczenie, a więc -[!!null]- jest równoznaczne zaprzeczeniu -[!true]-, a więc wynikiem będzie -[false]."
    },
    "27": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu: -[console.log(Math.round(19.95));]-?",
      "answers": [
        "-[20]-",
        "-[19]-",
        "-[19.9]-",
        "-[NaN]-"
      ],
      "explanation": "Metoda -[round]- obiektu -[Math]- przybliża liczbę do najbliższej liczby całkowitej, a więc będzie to -[20]-.\nLiczby od x.0 do x.49999... są zaokrąglane do x, z kolei liczby od x.5 do x.9999... zaokrąglane są do x+1."
    },
    "28": {
      "difficulty": 3,
      "question": "Który z typów danych nie jest typem prymitywnym?",
      "answers": [
        "object",
        "number",
        "string",
        "undefined"
      ],
      "explanation": "Typy danych dzielimy na proste i złożone. Proste to takie, które pod zmienną trzymają jedną wartość - np. liczbę, string, czy wartość boolean. Złożone to typy trzymające referencję do danych, jest to -[object]- i -[function]-.",
      "moreInfoUrl": "https://www.modestprogrammer.pl/typy-wartosciowe-oraz-typy-referencyjne-w-javascript"
    },
    "29": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu: -[console.log(typeof false);]-?",
      "answers": [
        "-['boolean']-",
        "-[false]-",
        "-['false']-",
        "-['type']-"
      ],
      "explanation": "Operator -[typeof]- zwraca typ podanej wartości jako string. Oznacza to, że dla -[false]-, które jest typu boolean dostaniemy string: -['boolean']-. Nie istnieje także żaden z typów: -['false']-, -['true']- czy -['type']-."
    },
    "30": {
      "difficulty": 2,
      "question": "Jaki będzie wynik tego kodu?:--[var liczba = 2;\nvar liczba = 5;\n\nconsole.log(liczba);]--",
      "answers": [
        "-[5]-",
        "-[2]-",
        "Wystąpi błąd, ponieważ zmienna -[liczba]- jest już zadeklarowana.",
        "Wystąpi błąd, ponieważ zmienna -[liczba]- nie może mieć zmienionej wartości."
      ],
      "explanation": "Przed nadejściem zmiennych -[let]- i -[const]- nie trudno było o pomyłkę. Javascript pozwalał na wiele rzeczy, między innymi na wielokrotne deklarowanie tej samej zmiennej. Jest to całkowicie bezcelowy zabieg, najczęściej spowodowanym błędem ludzkim. Zmienna -[let]- czy też -[strict mode]- eliminują taką możliwość, zgłaszając błąd."
    },
    "31": {
      "difficulty": 3,
      "question": "Jaki będzie wynik tego kodu?:--[const numbers = [10, 20, 30];\nconst [a, b, c] = numbers;\n\nconsole.log(b);]--",
      "answers": [
        "-[20]-",
        "-[10]-",
        "-[30]-",
        "Wystąpi błąd."
      ],
      "explanation": "Jest to tzw. destrukturyzacja obiektu (bądź tablicy). Kolejne elementy tablicy -[numbers]- zostają zadeklarowane jako -[a]-, -[b]- oraz -[c]-, stąd -[b]- wynosi -[20]-."
    },
    "32": {
      "difficulty": 3,
      "question": "Jaki będzie wynik tego kodu: -[console.log(true + true);]-?",
      "answers": [
        "-[2]-",
        "-[1]-",
        "-[true]-",
        "-[NaN]-"
      ],
      "explanation": "Wynikiem będzie -[2]-, ponieważ operator -[+]- konwertuje obie wartości na typ -[number]-. W tym momencie warto wiedzieć, że -[Number(false)]- da nam -[0]-, z kolei -[Number(true)]- da -[1]-. Ostatecznie -[1]- + -[1]- daje -[2]-."
    },
    "33": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tego kodu?:--[const tablica = [1, 2, 3, 4];\nconsole.log(tablica.push(5) - tablica.pop());]--",
      "answers": [
        "-[0]-",
        "-[5]-",
        "-[NaN]-",
        "-[1]-"
      ],
      "explanation": "Aby dokładnie wiedzieć jaki będzie wynik należy rozumieć co zwracają metody -[push]- i -[pop]-. Ta pierwsza zwróci nową długość tablicy, podczas gdy ostatnia zwróci (i usunie z tablicy) ostatni element.\nW wyniku tych działań odejmujemy od siebie długość tablicy -[[1, 2, 3, 4, 5]]- --- czyli -[5]- od ostatniego elementu, czyli -[5]-."
    },
    "34": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tego kodu?:--[const zbior = new Set([1, 1, 2, 2, 3, 4, 4, 4]);\nconsole.log([...zbior]);]--",
      "answers": [
        "-[[1, 2, 3, 4]]-",
        "-[[1, 1, 2, 2, 3, 4, 4, 4]]-",
        "-[11223444]-",
        "Wystąpi błąd."
      ],
      "explanation": "-[Set]- to obiekt przechowywujący unikalne wartości każdego typu. W wyniku czego utworzenie zbioru: -[Set([1, 1, 2, 2])]- automatycznie utworzy nam zbiór z elementami -[[1, 2]]-. Przypisanie destrukturyzujące (-[...zbior]-) tworzy nam nową tablicę na podstawie iterowanego obiektu - czyli tablicy, obiektu, Setu."
    },
    "35": {
      "difficulty": 4,
      "question": "Co wypisze nam -[console.log]-?:--[class User {\n  getName() {}\n}\n\nconsole.log(typeof User);]--",
      "answers": [
        "-['function']-",
        "-['object']-",
        "-['class']-",
        "-['string']-"
      ],
      "explanation": "Klasy w Javascripcie to nic innego jak funkcje, owinięte w tzw. -_syntactic sugar_- (pol. \"lukier składniowy\") czyli ładną otoczką upiększającą i ułatwiającą składnię języka. Wszystko co napiszemy klasami, możemy napisać również funkcjami."
    },
    "36": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tego kodu: -[console.log('good' > 'bad');]-?",
      "answers": [
        "-[true]-",
        "-[false]-",
        "-[NaN]-",
        "Wystąpi błąd, ponieważ stringów nie można porównywać."
      ],
      "explanation": "Stringi można porównywać, co więcej - każda kolejna litera alfabetu jest \"większa\" od poprzedniej, a każda mała litera jest \"większa\" od dużej. Wynika to z faktu, że porównywane są kody ASCII tych znaków. W przypadku dłuższych stringów porównywane są one znak po znaku, czyli -['kot' > 'koc']- bo -['t' > 'c']-."
    },
    "37": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tego kodu: -[console.log('toString' in {});]-?",
      "answers": [
        "-[true]-",
        "-[false]-",
        "-[undefined]-",
        "Wystąpi błąd."
      ],
      "explanation": "-['toString']- to nazwa metody obiektów, umożliwiającej wypisanie obiektu jako stringa. Oczywiście \"wydrukowanie\" zakończy się prawdpodobnie rezultatem -['[object Object]']-, o ile prototyp nie jest inny, ale zadziała dobrze dla innego obiektu - tablicy: -[[1, 2, 3,].toString()]- => -[\"1,2,3\"]-."
    },
    "38": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tego kodu?:--[var x = 10;\nvar wynik = 50;\n\n(function() {\n  console.log(x);\n  var x = 20;\n})();]--",
      "answers": [
        "-[undefined]-",
        "-[10]-",
        "-[20]-",
        "-[50]-"
      ],
      "explanation": "Wynik to rezultat procesu hoistingu --- jako że deklarujemy w funkcji nową zmienną -[x]-, zostaje ona wyniesiona do góry, przed naszego -[console.log]-a, co skutkuje tym, że -[x]- istnieje, ale nie ma zdefiniowanej wartości. -[x]- wynosiłoby -[10]-, gdyby nie ponowna deklaracja zmiennej."
    },
    "39": {
      "difficulty": 4,
      "question": "Co należy podstawić za -[_]-, aby -[console.log]- wypisał -[true]-?:--[const x = _;\nconsole.log(x !== x);]--",
      "answers": [
        "-[NaN]-",
        "-[undefined]-",
        "-[Infinity]-",
        "-[Math.random()]-"
      ],
      "explanation": "-[NaN]- nie stosuje się do reguł arytmetyki --- zarówno -[0 > NaN]-, -[0 == NaN]-, -[0 === NaN]- jak i -[0 < NaN]- zwróci false. Nawet -[NaN === NaN]-."
    },
    "40": {
      "difficulty": 3,
      "question": "Jaki będzie rezultat tego kodu?:--[const array = new Array(6);\nconsole.log(array[0]);]--",
      "answers": [
        "-[undefined]-",
        "-[6]-",
        "-[0]-",
        "-[null]-"
      ],
      "explanation": "-[new Array(6)]- tworzy taką oto tablicę: -[[undefined, undefined, undefined, undefined, undefined, undefined]]-."
    },
    "41": {
      "difficulty": 4,
      "question": "Jaki będzie wynik tego kodu?:--[const User = function() {};\n\nUser.prototype = {\n  name: 'Adam'\n};\n\nconst user = new User();\n\nUser.prototype = {\n  name: 'Bartek'\n};\n\nconsole.log(user.name);]--",
      "answers": [
        "-['Adam']-",
        "-['Bartek']-",
        "-[undefined]-",
        "Wystąpi błąd."
      ],
      "explanation": "Kod polega na stworzeniu obiektu User jako pustej funkcji - niczym tworzenie pustej klasy User. Prototyp obiektu to jego domyślne pola tworzone podczas tworzenia obiektu (np. pole -[name]-), dlatego też zmiana prototypu po utworzeniu już instancji tego obiektu niczego nie zmienia. Aby dokonać takiej zmiany, musielibyśmy użyć -[Object.setPrototypeOf]-."
    }
  }
}
